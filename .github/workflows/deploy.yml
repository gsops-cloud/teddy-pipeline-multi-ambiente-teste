name: Deploy Multi-Ambiente

on:
  push:
    branches:
      - develop
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - develop
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente alvo (dev, staging ou prod)'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      terraform_action:
        description: 'Ação do Terraform (apply ou destroy)'
        required: true
        type: choice
        options:
          - apply
          - destroy
        default: 'apply'
      aws_region:
        description: 'Região AWS'
        required: false
        type: string
        default: 'us-east-1'

env:
  # Variáveis globais essenciais (máximo 3)
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/develop' && 'dev' || github.ref == 'refs/heads/main' && 'staging' || 'prod') }}
  AWS_REGION: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  TERRAFORM_ACTION: ${{ github.event.inputs.terraform_action || 'apply' }}
  
  # Variáveis derivadas
  TERRAFORM_DIR: terraform
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  # Validação do Terraform
  validate:
    name: Validar Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout código
        uses: actions/checkout@v4
      
      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Validar Terraform
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform init -backend=false
          terraform fmt -check -recursive || terraform fmt -recursive
          terraform validate

  # Build da imagem Docker
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name != 'pull_request'
    outputs:
      image-uri: ${{ steps.image.outputs.uri }}
      image-tag: ${{ env.DOCKER_IMAGE_TAG }}
    steps:
      - name: Checkout código
        uses: actions/checkout@v4
      
      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login no Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Criar repositório ECR se não existir
        env:
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME || 'teddy-app' }}
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository \
            --repository-name $ECR_REPOSITORY \
            --region ${{ env.AWS_REGION }} \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
      
      - name: Build e Push Docker Image
        id: image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME || 'teddy-app' }}
          IMAGE_TAG: ${{ env.DOCKER_IMAGE_TAG }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          docker tag $IMAGE_URI $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "uri=$IMAGE_URI" >> $GITHUB_OUTPUT

  # Deploy para DEV
  deploy-dev:
    name: Deploy DEV
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/develop') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment:
      name: dev
      url: https://dev.teddy.example.com
    concurrency:
      group: deploy-all-environments
      cancel-in-progress: false
    env:
      ENVIRONMENT: dev
      IMAGE_URI: ${{ needs.build.outputs.image-uri }}
      TERRAFORM_ACTION: ${{ github.event.inputs.terraform_action || 'apply' }}
    steps:
      - name: Checkout código
        uses: actions/checkout@v4
      
      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      
      - name: Instalar dependências
        run: pip install -r requirements.txt
      
      - name: Sincronizar variáveis
        run: |
          python3 scripts/sync_variables.py --environment dev --direction to-aws --region ${{ env.AWS_REGION }}
        env:
          DEV_DATABASE_URL: ${{ secrets.DEV_DATABASE_URL }}
          DEV_API_KEY: ${{ secrets.DEV_API_KEY }}
      
      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Criar recursos de backend se não existirem
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_DEV || 'teddy-terraform-state-dev' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_DEV || 'teddy-terraform-locks-dev' }}
        run: |
          # Criar bucket S3 se não existir
          if ! aws s3 ls "s3://$STATE_BUCKET" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "Bucket $STATE_BUCKET já existe"
          else
            echo "Criando bucket $STATE_BUCKET..."
            aws s3 mb s3://$STATE_BUCKET --region ${{ env.AWS_REGION }} || true
            aws s3api put-bucket-versioning \
              --bucket $STATE_BUCKET \
              --versioning-configuration Status=Enabled || true
            aws s3api put-bucket-encryption \
              --bucket $STATE_BUCKET \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true
          fi
          
          # Criar tabela DynamoDB se não existir
          if aws dynamodb describe-table --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} 2>&1 | grep -q 'ResourceNotFoundException'; then
            echo "Criando tabela DynamoDB $LOCK_TABLE..."
            aws dynamodb create-table \
              --table-name $LOCK_TABLE \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }} || true
            echo "Aguardando tabela ficar ativa..."
            aws dynamodb wait table-exists --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} || true
          else
            echo "Tabela $LOCK_TABLE já existe"
          fi
      
      - name: Criar arquivo de backend
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_DEV || 'teddy-terraform-state-dev' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_DEV || 'teddy-terraform-locks-dev' }}
        run: |
          cat > backend-dev.conf << EOF
          bucket         = "$STATE_BUCKET"
          key            = "terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "$LOCK_TABLE"
          EOF
      
      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform init -backend-config=backend-dev.conf
          terraform workspace select dev || terraform workspace new dev
      
      - name: Terraform Apply ou Destroy
        id: terraform
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Executando Terraform ${{ env.TERRAFORM_ACTION }} para ambiente dev"
          if [ "${{ env.TERRAFORM_ACTION }}" == "destroy" ]; then
            terraform destroy -auto-approve \
              -var="environment=dev" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          else
            terraform apply -auto-approve \
              -var="environment=dev" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          fi
      
      - name: Deploy ECS
        if: env.TERRAFORM_ACTION == 'apply'
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Fazendo deploy no ECS para ambiente dev"
          python3 scripts/deploy_ecs.py \
            --environment dev \
            --image-tag ${{ env.DOCKER_IMAGE_TAG }} \
            --base-image $DOCKER_IMAGE \
            --action deploy \
            --region ${{ env.AWS_REGION }}
      
      - name: Obter e exibir URL do ALB
        if: env.TERRAFORM_ACTION == 'apply'
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          ALB_URL=$(terraform output -raw alb_url 2>/dev/null || echo "http://$(terraform output -raw alb_dns_name 2>/dev/null || echo 'pending')")
          echo "::notice title=ALB URL::Aplicação disponível em: $ALB_URL"
          echo "ALB_URL=$ALB_URL" >> $GITHUB_ENV
      
      - name: Notificação de Falha
        if: failure()
        run: |
          python3 scripts/notify_whatsapp.py \
            --environment dev \
            --status failed \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}
      
      - name: Notificação de Sucesso
        if: success()
        run: |
          ACTION_TEXT=${{ env.TERRAFORM_ACTION == 'destroy' && 'destruição' || 'deploy' }}
          python3 scripts/notify_whatsapp.py \
            --environment dev \
            --status success \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}

  # Deploy para STAGING
  deploy-staging:
    name: Deploy STAGING
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main' && !startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.teddy.example.com
    concurrency:
      group: deploy-all-environments
      cancel-in-progress: false
    env:
      ENVIRONMENT: staging
      IMAGE_URI: ${{ needs.build.outputs.image-uri }}
      TERRAFORM_ACTION: ${{ github.event.inputs.terraform_action || 'apply' }}
    steps:
      - name: Checkout código
        uses: actions/checkout@v4
      
      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      
      - name: Instalar dependências
        run: pip install -r requirements.txt
      
      - name: Sincronizar variáveis
        run: |
          python3 scripts/sync_variables.py --environment staging --direction to-aws --region ${{ env.AWS_REGION }}
        env:
          STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          STAGING_API_KEY: ${{ secrets.STAGING_API_KEY }}
      
      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Criar recursos de backend se não existirem
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_STAGING || 'teddy-terraform-state-staging' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_STAGING || 'teddy-terraform-locks-staging' }}
        run: |
          # Criar bucket S3 se não existir
          if ! aws s3 ls "s3://$STATE_BUCKET" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "Bucket $STATE_BUCKET já existe"
          else
            echo "Criando bucket $STATE_BUCKET..."
            aws s3 mb s3://$STATE_BUCKET --region ${{ env.AWS_REGION }} || true
            aws s3api put-bucket-versioning \
              --bucket $STATE_BUCKET \
              --versioning-configuration Status=Enabled || true
            aws s3api put-bucket-encryption \
              --bucket $STATE_BUCKET \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true
          fi
          
          # Criar tabela DynamoDB se não existir
          if aws dynamodb describe-table --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} 2>&1 | grep -q 'ResourceNotFoundException'; then
            echo "Criando tabela DynamoDB $LOCK_TABLE..."
            aws dynamodb create-table \
              --table-name $LOCK_TABLE \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }} || true
            echo "Aguardando tabela ficar ativa..."
            aws dynamodb wait table-exists --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} || true
          else
            echo "Tabela $LOCK_TABLE já existe"
          fi
      
      - name: Criar arquivo de backend
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_STAGING || 'teddy-terraform-state-staging' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_STAGING || 'teddy-terraform-locks-staging' }}
        run: |
          cat > backend-staging.conf << EOF
          bucket         = "$STATE_BUCKET"
          key            = "terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "$LOCK_TABLE"
          EOF
      
      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform init -backend-config=backend-staging.conf
          terraform workspace select staging || terraform workspace new staging
      
      - name: Terraform Apply ou Destroy
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Executando Terraform ${{ env.TERRAFORM_ACTION }} para ambiente staging"
          if [ "${{ env.TERRAFORM_ACTION }}" == "destroy" ]; then
            terraform destroy -auto-approve \
              -var="environment=staging" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          else
            terraform apply -auto-approve \
              -var="environment=staging" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          fi
      
      - name: Deploy ECS
        if: env.TERRAFORM_ACTION == 'apply'
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Fazendo deploy no ECS para ambiente staging"
          python3 scripts/deploy_ecs.py \
            --environment staging \
            --image-tag ${{ env.DOCKER_IMAGE_TAG }} \
            --base-image $DOCKER_IMAGE \
            --action deploy \
            --region ${{ env.AWS_REGION }}
      
      - name: Obter e exibir URL do ALB
        if: env.TERRAFORM_ACTION == 'apply'
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          ALB_URL=$(terraform output -raw alb_url 2>/dev/null || echo "http://$(terraform output -raw alb_dns_name 2>/dev/null || echo 'pending')")
          echo "::notice title=ALB URL::Aplicação disponível em: $ALB_URL"
          echo "ALB_URL=$ALB_URL" >> $GITHUB_ENV
      
      - name: Notificação de Falha
        if: failure()
        run: |
          python3 scripts/notify_whatsapp.py \
            --environment staging \
            --status failed \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}
      
      - name: Notificação de Sucesso
        if: success()
        run: |
          python3 scripts/notify_whatsapp.py \
            --environment staging \
            --status success \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}

  # Deploy para PROD
  deploy-prod:
    name: Deploy PROD
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    environment:
      name: prod
      url: https://teddy.example.com
    concurrency:
      group: deploy-all-environments
      cancel-in-progress: false
    env:
      ENVIRONMENT: prod
      IMAGE_URI: ${{ needs.build.outputs.image-uri }}
      TERRAFORM_ACTION: ${{ github.event.inputs.terraform_action || 'apply' }}
    steps:
      - name: Checkout código
        uses: actions/checkout@v4
      
      - name: Configurar AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
      
      - name: Instalar dependências
        run: pip install -r requirements.txt
      
      - name: Sincronizar variáveis
        run: |
          python3 scripts/sync_variables.py --environment prod --direction to-aws --region ${{ env.AWS_REGION }}
        env:
          PROD_DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
          PROD_API_KEY: ${{ secrets.PROD_API_KEY }}
      
      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Criar recursos de backend se não existirem
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_PROD || 'teddy-terraform-state-prod' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_PROD || 'teddy-terraform-locks-prod' }}
        run: |
          # Criar bucket S3 se não existir
          if ! aws s3 ls "s3://$STATE_BUCKET" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "Bucket $STATE_BUCKET já existe"
          else
            echo "Criando bucket $STATE_BUCKET..."
            aws s3 mb s3://$STATE_BUCKET --region ${{ env.AWS_REGION }} || true
            aws s3api put-bucket-versioning \
              --bucket $STATE_BUCKET \
              --versioning-configuration Status=Enabled || true
            aws s3api put-bucket-encryption \
              --bucket $STATE_BUCKET \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true
          fi
          
          # Criar tabela DynamoDB se não existir
          if aws dynamodb describe-table --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} 2>&1 | grep -q 'ResourceNotFoundException'; then
            echo "Criando tabela DynamoDB $LOCK_TABLE..."
            aws dynamodb create-table \
              --table-name $LOCK_TABLE \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }} || true
            echo "Aguardando tabela ficar ativa..."
            aws dynamodb wait table-exists --table-name $LOCK_TABLE --region ${{ env.AWS_REGION }} || true
          else
            echo "Tabela $LOCK_TABLE já existe"
          fi
      
      - name: Criar arquivo de backend
        working-directory: ${{ env.TERRAFORM_DIR }}
        env:
          STATE_BUCKET: ${{ secrets.TERRAFORM_STATE_BUCKET_PROD || 'teddy-terraform-state-prod' }}
          LOCK_TABLE: ${{ secrets.TERRAFORM_LOCK_TABLE_PROD || 'teddy-terraform-locks-prod' }}
        run: |
          cat > backend-prod.conf << EOF
          bucket         = "$STATE_BUCKET"
          key            = "terraform.tfstate"
          region         = "${{ env.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "$LOCK_TABLE"
          EOF
      
      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform init -backend-config=backend-prod.conf
          terraform workspace select prod || terraform workspace new prod
      
      - name: Terraform Apply ou Destroy
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Executando Terraform ${{ env.TERRAFORM_ACTION }} para ambiente prod"
          if [ "${{ env.TERRAFORM_ACTION }}" == "destroy" ]; then
            terraform destroy -auto-approve \
              -var="environment=prod" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          else
            terraform apply -auto-approve \
              -var="environment=prod" \
              -var="docker_image=$DOCKER_IMAGE" \
              -var="docker_image_tag=${{ env.DOCKER_IMAGE_TAG }}" \
              -var="aws_region=${{ env.AWS_REGION }}"
          fi
      
      - name: Deploy ECS
        if: env.TERRAFORM_ACTION == 'apply'
        run: |
          DOCKER_IMAGE=$(echo "${{ env.IMAGE_URI }}" | cut -d: -f1)
          echo "Fazendo deploy no ECS para ambiente prod"
          python3 scripts/deploy_ecs.py \
            --environment prod \
            --image-tag ${{ env.DOCKER_IMAGE_TAG }} \
            --base-image $DOCKER_IMAGE \
            --action deploy \
            --region ${{ env.AWS_REGION }}
      
      - name: Obter e exibir URL do ALB
        if: env.TERRAFORM_ACTION == 'apply'
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          ALB_URL=$(terraform output -raw alb_url 2>/dev/null || echo "http://$(terraform output -raw alb_dns_name 2>/dev/null || echo 'pending')")
          echo "::notice title=ALB URL::Aplicação disponível em: $ALB_URL"
          echo "ALB_URL=$ALB_URL" >> $GITHUB_ENV
      
      - name: Notificação de Falha
        if: failure()
        run: |
          python3 scripts/notify_whatsapp.py \
            --environment prod \
            --status failed \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}
      
      - name: Notificação de Sucesso
        if: success()
        run: |
          python3 scripts/notify_whatsapp.py \
            --environment prod \
            --status success \
            --commit ${{ github.sha }} \
            --pipeline-url ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_WHATSAPP_FROM: ${{ secrets.TWILIO_WHATSAPP_FROM }}
          TWILIO_WHATSAPP_TO: ${{ secrets.TWILIO_WHATSAPP_TO }}